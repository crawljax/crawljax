package com.crawljax.core.state.duplicatedetection;

import java.util.HashSet;
import java.util.Set;

import com.google.common.collect.Sets;

/**
 * Fingerprint data-object for Broder-specific hashes generated by NearDuplicateDetectionBroder.
 * @see NearDuplicateDetectionBroder
 */
public class BroderFingerprint implements Fingerprint {
	
	private double defaultThreshold;
	private int[] hashes;
	
	/**
	 * Constructor for this used by the NearDuplicateDetectionBroder
	 * @param hashes the generated hashes on which this fingerprint is based.
	 * @param defaultThreshold the default threshold, which is used when no threshold is provided.
	 */
	public BroderFingerprint(int[] hashes, double defaultThreshold) {
		this.defaultThreshold = defaultThreshold;
		this.hashes = hashes;
	}
	
	/**
	 * Constructor without setting the defaultThreshold, which will be set to 1.
	 * @param hash the generated hash on which this fingerprint is based.
	 */
	public BroderFingerprint(int[] hashes) {
		this.hashes = hashes;
		this.defaultThreshold = 1;
	}
	
	@Override
	public boolean isNearDuplicateHash(Fingerprint other) {
		return (this.getDistance(other) <= this.defaultThreshold);
	}
	
	@Override
	public boolean isNearDuplicateHash(Fingerprint other, double threshold) {
		return (this.getDistance(other) <= threshold);
	}

	/**
	 * Get the distance between two sets.
	 * 
	 * @return Zero if both sets contains exactly the same hashes and one if the two sets contains
	 *         all different hashes and values in between for the corresponding difference. The
	 *         closer the value is to zero, the more hashes in the sets are the same.
	 */
	@Override
	public double getDistance(Fingerprint other) {
		BroderFingerprint that = assertFingerprintType(other);
		return 1 - this.getJaccardCoefficient(this.hashes, that.hashes);
	}
	
	/**
	 * Checks whether the other Fingerprint is of the same type as this, otherwise throw an exception.
	 * @param other the Fingerprint of which the type should be the same as this.
	 */
	private BroderFingerprint assertFingerprintType(Fingerprint other) {
		if(!this.getClass().isInstance(other))
			throw new DuplicateDetectionException("Cannot compare fingerprints of different types. (this: " + this.getClass() + " vs. that: " + other.getClass() + ")");
		return (BroderFingerprint) other;
	}

	/**
	 * Calculate the Jaccard Coefficient (http://en.wikipedia.org/wiki/Jaccard_index) of two sets of integers.
	 * @param state1 first set of integers
	 * @param state2 second set of integers
	 * @return the Jaccard Coefficient of the two arguments.
	 */
	private double getJaccardCoefficient(int[] state1, int[] state2) {
		Set<Integer> setOfFirstArg = new HashSet<Integer>(state1.length);
		Set<Integer> setOfSecondArg = new HashSet<Integer>(state2.length);
		for (int state : state1) {
			setOfFirstArg.add(state);
		}
		for (int state : state2) {
			setOfSecondArg.add(state);
		}
		// Do the Jaccard index calculation: union(A,B)/intersect(A,B)
		double unionCount = Sets.union(setOfFirstArg, setOfSecondArg).size();
		double intersectionCount = Sets.intersection(setOfFirstArg, setOfSecondArg).size();
		return (intersectionCount / unionCount);
	}
	
	/**
	 * A fingerprint equals another fingerprint, when the hashes are completely the same.
	 * Another implicit way of invoking an equals is to invoke isNearDuplicateHash(other,0).
	 */
	@Override
    public boolean equals(Object obj) {
	    if (this == obj)
		    return true;
	    if (obj == null)
		    return false;
	    if (getClass() != obj.getClass())
		    return false;
	    BroderFingerprint other = (BroderFingerprint) obj;
	    return this.isNearDuplicateHash(other, 0);
    }

}
