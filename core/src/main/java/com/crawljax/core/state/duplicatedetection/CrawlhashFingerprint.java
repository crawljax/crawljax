package com.crawljax.core.state.duplicatedetection;

import com.google.common.annotations.VisibleForTesting;

/**
 * Fingerprint data-object for Crawlhash-specific hashes generated by NearDuplicateDetectionCrawlhash32.
 * @see NearDuplicateDetectionCrawlhash32
 */
public class CrawlhashFingerprint implements Fingerprint {

	private int hash;
	private double defaultThreshold;

	/**
	 * Constructor for this used by the NearDuplicateDetectionCrawlhash32
	 * @param hash the generated hash on which this fingerprint is based.
	 * @param defaultThreshold the default threshold, which is used when no threshold is provided.
	 */
	public CrawlhashFingerprint(int hash, double defaultThreshold) {
		this.hash = hash;
		this.defaultThreshold = defaultThreshold;
	}
	
	@Override
	public boolean isNearDuplicateHash(Fingerprint other) {
		return ((double) getDistance(other)) <= defaultThreshold;
	}

	@Override
	public boolean isNearDuplicateHash(Fingerprint other, double threshold) {
		return ((double) getDistance(other)) <= threshold;
	}
	
	@Override
	public double getDistance(Fingerprint other) {
		fingerprintTypeCheck(other);
		return hammingDistance(this.hash, other.getHashesAsIntArray()[0]);
	}
	
	/**
	 * Checks whether the other Fingerprint is of the same type as this, otherwise throw an exception.
	 * @param other the Fingerprint of which the type should be the same as this.
	 */
	private void fingerprintTypeCheck(Fingerprint other) {
		if(this.getClass().isInstance(other))
			throw new DuplicateDetectionException("Cannot compare fingerprints of different types. (this: " + this.getClass() + " vs. that: " + other.getClass() + ")");
	}
	
	/**
	 * The Hamming-distance (http://en.wikipedia.org/wiki/Hamming_distance) calculates the distance between two hashes.
	 * @param hash1 int-represented bit-hash
	 * @param hash2 int-represented bit-hash
	 * @return The distance is specified as the minimum number of bit-character changes needed to transform hash1 to hash2.
	 */
	@VisibleForTesting
	public int hammingDistance(int hash1, int hash2) {
		int i = hash1 ^ hash2;
		i = i - ((i >>> 1) & 0x55555555);
		i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);
		i = (i + (i >>> 4)) & 0x0f0f0f0f;
		i = i + (i >>> 8);
		i = i + (i >>> 16);
		return i & 0x3f;
	}

	@Override
	public int[] getHashesAsIntArray() {
		return new int[]{hash};
	}

}
